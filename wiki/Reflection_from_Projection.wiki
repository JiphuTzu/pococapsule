#summary A discussion of "Reflection from Projection"
#labels Phase-Design,Featured

== Non-invasive IoC containers and Reflection ==
Non-invasive IoC containers support _container agnostic_ components. These components neither query container runtime services (configuration directories or contexts) nor support any container pre-defined callback control interfaces or operation signatures. Hence, instead of dealing with homogeneous standardized components, these containers have to manipulate plain-old C++/Java objects (components) through their heterogeneous user-defined interfaces or function signatures. The conventional solution used by various IoC containers is based on dynamic invocations of Java (as well as C# etc.) reflection. However, many programming languages runtime environment, such as C and C++, or language environments, such as JavaME CLDC, do not come with this kind of language native reflection mechanism.

Previous attempts on implementing IoC containers in these non-reflective static languages/environments were largely misleaded by various phantom requirements that assumed the goals here were mainly to build a Java reflection like facility, to support a XML scripting environement, and/or to manipulate third party components without even knowing their relevant API signatures. The very fundamental objectives of IoC containers, however, were unfortunately neglected. 

IoC containers are neither to offer reflection a la Java nor to support another scripting language. Instead, IoC containers are mainly for the following objectives:

  * To separate plumbing logic (component life cycle controls, wirings, initial property settings etc.) from business logic, and shift them (plumbing logic) into the framework.
  * To assemble, deploy, and configure applications declaratively (by expressing what they are alike, rather than the procedures of how to build them step-by-step). Ideally, in case of configuration parameter value changes, an application should be reconfigurable by only modifying declarative descriptions and do not force code recompilations.
  * To support component and declarative model-transformation based _ontological_ and _domain-specific_ modeling (DSM).

Therefore, if you are looking for a reflection engine or a scripting environment for C++, you should stop reading about IoC containers and this article.

== Reflection from Projection ==
Based on these considerations, PocoCapsule uses the so-called "_reflection from projection_" (RfP) scenario to facilitate dynamic invocations. By this scenario, instead of having all aspects of all involved components to be thoroughly reflectible, users only need to extract those dynamic proxies (and other necessary mate data) that are _projected_ (i.e. going to be used) by given applications described in their setup descriptions. The development utility *pxgenproxy* is provided in PocoCapsule to perform this _projection_, namely to extract and generate dynamic invocation proxies from application setup descriptions.

Unlike UML or CASE tools, this _projection_ scenario does not require users to provide component definitions. Also, unlike traditional (non-component) DSM tools, this _projection_ does not generate method invocation code with actual parameter values. Rather it only cares component wiring and configuring descriptions and only generate proxies (and necessary mate data) based on method invocation signatures referred in wiring and configuring involved components. This means users do not need to rebuild dynamic proxies in case of configuration parameter value changes.

== Worse is better ==
The RfP scenario seems to be inferior than other alternatives, such as pre-generate all dynamic proxies (and all mate data) for all aspects of all involved components (for instance, using GCC XML or SEAL Reflex). However, given the C++ (and C, JavaME CLDC as well) application background, this seemingly worse solution is a better one, unless one's purpose is not IoC but to pursue a full blown reflection engine or to support a scripting or debug environment.

  * RfP significantly reduces the excessive footprint of reflection code and mate data.
  * RfP is straightforward on various rigorous embedded systems where developers have to compromise with very primitive and not fully standard compliant C++ compilers.
  * RfP works well with C++ templates (as well as _[http://en.wikipedia.org/wiki/C%2B%2B0x C++0x]_ _[http://en.wikipedia.org/wiki/C%2B%2B0x#Concepts concepts]_), inline functions, and even macros.
  * RfP is easily applicable to other languages or environments (C, JavaME CLDC, Ada, COBOL). 
  * RfP works without requiring component implementation source code! 