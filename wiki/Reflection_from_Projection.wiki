#summary A discussion of "Reflection from Projection"
#labels Phase-Design,Featured

== Non-invasive IoC containers and Reflection ==
Non-invasive IoC containers support _container agnostic_ components. These components neither query container runtime services (configuration directories or contexts) nor support any container pre-defined callback control interfaces or operation signatures. Hence, instead of dealing with homogeneous standardized components, these containers have to manipulate plain-old C++/Java objects (components) through their heterogeneous user-defined interfaces or function signatures. The conventional solution used by various IoC containers for static typed languages relies on reflection based dynamic invocations. However, many static typed language runtime environments, such as C, C++, and JavaME CLDC, do not come with this kind of language native reflection mechanism.

== Phontom requirements ==
In the past, attempts on implementing IoC containers in these non-reflective static languages/environments were largely misleaded by various phantom requirements that assumed the goals here were mainly to build and utilize a Java reflection alike facility, to support a XML scripting environement, and/or to manipulate third party components without even knowing their relevant application programming interface (API) signatures (see discussions below). The very fundamental objectives of IoC containers, however, were unfortunately neglected. 

For instance, it was wrongly assumed that the purpose of IoC frameworks is to allow one to use third party components (which user defined API signatures) that do not have header files declaring their API signatures (classes). As a matter of fact, free from header files is neither an intended objective of nor a feature introduced by non-invasive IoC frameworks. Instead, it is merely a nature of specific language environments, such as Java, that have homogeneous application binary interface (ABI) and have application component API matedate built-in. If the intention was merely using components without header files, then IoC frameworks in most language environments would be unnecessary. Because, most of these environments, such as Java, were already free from separated header files even without IoC frameworks. 

Similarly, another popular illusion assumed that goal of IoC frameworks is to provide a scripting environments for assemblying/configuring applications without using compilers or other tools. Contrary to this, many real world IoC frameworks, such as PicoContainer and SpringFramework IoC (in its Java Configuration), simply have their application wiring/configuration descriptions written in Java code that have to be compiled before use. Even if XML descriptions were used, it wasn't uncommon that they need to be packaged into .ear, .war, .jar, or .ZIP files using various tools.         

== Objectives ==
IoC containers are neither to offer reflection a la Java nor to support another scripting language. Instead, IoC containers are mainly for the following objectives:

  * To separate plumbing logic (component life cycle controls, wirings, initial property settings etc.) from business logic, and shift them (plumbing logic) into the framework.
  * To assemble, deploy, and configure applications declaratively (by expressing what they are alike, rather than the procedures of how to build them step-by-step). 
  * To support quick and dynamic (in non-development environments) application reconfigurations involving parameter value changes and component rewirings and replacement.
  * To support component and declarative model-transformation based _ontological_ and _domain-specific_ modeling (DSM).

Therefore, if you are looking for a reflection engine or a scripting environment for C++, you should stop reading about IoC containers and this article.

== Reflection from Projection ==
Based on these considerations, PocoCapsule uses the so-called "_reflection from projection_" (RfP) scenario to facilitate dynamic invocations. By this scenario, instead of having all aspects of all involved components to be thoroughly reflectible, users only need to extract those dynamic proxies (and other necessary mate data) that are _projected_ (i.e. going to be used) by given applications described in their setup descriptions. The development utility *pxgenproxy* is provided in PocoCapsule to perform this _projection_, namely to extract and generate dynamic invocation proxies from application setup descriptions.

Unlike UML or CASE tools, this _projection_ scenario does not require users to provide component definitions. Also, unlike traditional (non-component) DSM tools, this _projection_ does not generate method invocation code with actual parameter values. Rather it only cares component wiring and configuring descriptions and only generate proxies (and necessary mate data) based on method invocation signatures referred in wiring and configuring involved components. This means users do not need to rebuild dynamic proxies in case of configuration parameter value changes.

== Worse is better ==
The RfP scenario seems to be inferior than other alternatives, such as pre-generate all dynamic proxies (and all mate data) for all aspects of all involved components (for instance, using GCC XML or SEAL Reflex). However, given the C++ (and C, JavaME CLDC as well) application background, this seemingly worse solution is a better one, unless one's purpose is not IoC but to pursue a full blown reflection engine or to support a scripting or debug environment.

  * RfP significantly reduces the excessive footprint of reflection code and mate data.
  * RfP is straightforward on various rigorous embedded systems where developers have to compromise with very primitive and not fully standard compliant C++ compilers.
  * RfP works well with C++ templates (as well as _[http://en.wikipedia.org/wiki/C%2B%2B0x C++0x]_ _[http://en.wikipedia.org/wiki/C%2B%2B0x#Concepts concepts]_), inline functions, and even macros.
  * RfP is easily applicable to other languages or environments (C, JavaME CLDC, Ada, COBOL). 
  * RfP works without requiring component implementation source code! 