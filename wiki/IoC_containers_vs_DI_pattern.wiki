#summary IoC containers vs the DI design pattern
#labels Featured

== IoC containers are not about a design pattern ==

There are many widely spread myths about _inversion-of-control (IoC) containers_, such as: they are about a loose coupling design pattern, they are programming frameworks to facilitate such design, they are event-driven frameworks, or they are merely about the strategy pattern, etc. The top two myths are summarized as follows: 

1. _inversion of control_ (IoC) is a design pattern, known as the _dependency injection_ (DI), to achieve _loose coupling_ between application objects. To be specific, by externalizing object instantiation logic, this design pattern makes caller objects have only interface couplings and dependency references but no implementation coupling to callee objects. 

2. IoC containers (renamed as DI frameworks under thest myths) are simply programming frameworks that do DI. To be specific, the objectives of IoC/DI containers are to handle the externalized logic of instantiating application objects and then wiring them up through DI.

Misleaded by these myths, many people concluded, either disappointedly or scornfully, that the IoC/DI was merely an over hyped trivial programming design pattern they had manually used for years. Consequently, the significance and implications of IoC containers were constantly speculated or neglected, as expressed in a slogan from some DI folks: _“I was expecting a paradigm shift, and all I got was a lousy constructor”_.

[http://www.betaversion.org/%7Estefano/linotype/news/38/ Stefano] once pointed out what was wrong with this misunderstanding on IoC containers: _IoC is not even a design pattern, but a general principle that separates an API from a framework, based on who is in control. Dependency Injection misses that entirely and misleads the reader to believe that this is just another way of composing objects. I don’t blame Martin Fowler for that, I blame those who came up with IoC type 1,2,3 and missed the point entirely about the fact that IoC is not what Avalon *does* (so not a design pattern), but a much more general principle that Avalon simply *used*_.  This comment is quite right. The popular misunderstanding on IoC containers is mainly wrong on confusing IoC containers with the DI design pattern.  

Firstly, the intention of applying inversion of control in IoC containers is orthogonal to the purpose of DI design pattern of achieving loose coupling between application caller and callee components. This kind of loose coupling are also favorable in traditional non-IoC or hybrid component frameworks. Rather, IoC containers do not mind tight coupling between application components. For instance, IoC containers can be used equaly well to wire up a component with its dependency referenced by concrete implementation type rather than by interface or abstract class type. The primary purpose of applying _inversion of control_ in IoC containers is to achieve complete *_decoupling_* between the container and application components. This implies that application components not only have no tight coupling (i.e. no implementation coupling) to the container but also have no loose coupling either (i.e. no coupling to the container interface, no dependency reference to the container instance, and no callback operation signatures mandated by the container). Namely, application components are *_container agnostic_* and the containers are *_neutral_* and *_non-invasive_* to components. 

Secondly, although appearing as a common character and playing a critical role in all IoC containers, neither the _inversion of control_ in general nor the _dependency injection_ in particular is what IoC containers primarily focus to *_do_* but what they simply *_use_*. Namely, in IoC containers, it is not containers serve the IoC/DI, but the IoC/DI facilitates containers. This is just like an electric car is not about a car _for_ electricity, but about electricity _for_ the car. 

For years, these myths have been widely spread. Consequently, many frameworks that tagged as “IoC containers” nowadays are merely programming libraries focusing on _doing DI without leaving the same programming language_. Although these DI programming frameworks are useful in many cases, their objectives are orthogonal to and at a level different from those IoC containers that focus on assembling and deploying applications at component level. This is similar to the difference between traditional component frameworks (such as the old pre-2.x EJB and OMG CCM) that use table/directory lookup design and those programming frameworks or libraries that provide table/directory implementations (such as java.util, javax.naming, and C++ STL/boost libraries). To avoid further confusing, people have suggested differentiate those IoC containers from these DI programming frameworks or libraries.

== IoC containers are about application models as first class objects ==
By the suggested classification, the primary focus of IoC containers is to fabricate applications, from high level service and business logic components, based on separated assembly and deployment description modules. However, distinct from their counterpart in DI frameworks that emphasize on doing DI without leaving the imperative languages, these description modules in IoC containers have the following two features:

- Firstly, they are *_[http://en.wikipedia.org/wiki/Declarative_programming declarative]_* and describe the architecture models (namely *_what_* are the set of involved components, their configurations, constraints, and dependency relationships) of their applications rather than the _[http://en.wikipedia.org/wiki/Imperative_programming imperative]_ procedures (namely *_how_*) to set up these architectures.

- Secondly, they are *_[http://en.wikipedia.org/wiki/First-class_object first class objects]_* of the framework. This means that these description modules can be manipulated (such as to be generated, transformed, refactored, aggregated, filtered, queried, and verified) explicitly by high level declarative code.

These two seemingly plain features not only have non-trivial and paradigm shifting implications far beyond the DI design pattern or the IoC principle itself, but also differentiate IoC containers from imperative scripting language environments.

The declarative feature of these description modules makes the architecture models of their applications intuitive, self-documenting, and helps one to see the forest (architecture) beyond the trees (individual components) of the described applications. It also allows domain, context, and referential constraints to be imposed on these description modules and implies more rich and strong schema check than the primitive type check of classic imperative languages (Java and C++). 

The second feature highlighted by this article turns out to be more distinct and is the one that implies the paradigm shift (especially in imperative language, such as Java and C++, environments). However, this feature has largely been neglected or unaware even by many IoC folks. Although many IoC containers happen to support this feature unintentionally, few of them have intentionally attempted to leverage it, largely due to the religious of everything should be and better to be done within the original imperative programming language.

As discussed in the article of [http://www.pocomatic.com/docs/whitepapers/dsm/ Domain Specific Modeling in IoC frameworks], component frameworks, either IoC or not, all face the dilemma of expressiveness and diversity vs. intuitiveness and simplicity of the schema(s) of their declarative description modules. Knowing that there is no one-size-fits-all solution, the best approach to address this dilemma is to allow users to define customized, highly expressive, and error-proof domain specific modeling (DSM) schema(s) for their specific application architecture descriptions. However, supporting these DSM schemas by a component framework implies low level and error-prone programming effort that tend to be very cost-ineffective. The second feature of IoC description modules enables a seamless and cost-effective solution here. Because these modules are manipulatable by declarative code, it allows error-proof DSM transformation templates to be much easily authored at high level. Then, with these templates, description modules in DSMs can be transformed into modules in built-in core schemas of IoC containers, as illustrated by [http://code.google.com/p/pococapsule PocoCapsule IoC and DSM framework] and its [http://www.pocomatic.com/docs/cpp-examples/ examples].