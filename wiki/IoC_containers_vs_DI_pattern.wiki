#summary A whitepaper on IoC vs DI

== IoC containers are not about a design pattern or a programming library ==

By a fairly popular misunderstanding, the meaning of _inversion-of-control_ (IoC) containers is summarized in the following two conclusions:

- Firstly, _inversion of control_ (IoC) is a programming design pattern also known as _dependency injection_ (DI). The objective of this design pattern is to achieve _loose coupling_ between application components by outsourcing instantiation logic of dependent components. To be specific, the loose coupling referred in this design pattern means that caller components have only interface couplings and dependency references but no implementation coupling to callee components.

- Secondly, IoC containers (usually referred to as DI frameworks from this misunderstanding) are simply programming frameworks that do DI. To be specific, the objectives of IoC/DI containers are to handle the outsourced logic of instantiating application components and then wiring them up through DI.

From this misunderstanding, many people have either disappointedly or scornfully concluded that the IoC/DI is merely an over hyped trivial programming design pattern they have manually used for years. Consequently, the significance and implications of IoC containers are constantly speculated or neglected, as expressed in a slogan from some DI folks: _“I was expecting a paradigm shift, and all I got was a lousy constructor”_.

[http://www.betaversion.org/%7Estefano/linotype/news/38/ Stefano] once pointed out what is wrong with this misunderstanding on IoC containers: _IoC is not even a design pattern, but a general principle that separates an API from a framework, based on who is in control. Dependency Injection misses that entirely and misleads the reader to believe that this is just another way of composing objects. I don’t blame Martin Fowler for that, I blame those who came up with IoC type 1,2,3 and missed the point entirely about the fact that IoC is not what Avalon *_does_* (so not a design pattern), but a much more general principle that Avalon simply *_used_*_.  This comment is quite right. The popular misunderstanding on IoC containers is mainly wrong on confusing IoC containers with the DI design pattern.  

Firstly, the intention of applying inversion of control in IoC containers is orthogonal to the purpose of DI design pattern of achieving loose coupling between application caller and callee components. This kind of loose coupling has already been accomplished in traditional non-IoC or hybrid component frameworks. Rather, IoC containers use inversion of control primarily for the purpose of decoupling application components from the containers. This decoupling implies that application components not only have no coupling to the container internal implementation but also have neither coupling to the container interface, nor dependency reference to the container instance, and nor callback operation signatures mandated by the container. Namely, application components become container agnostic and the containers become neutral to component models. On the other side, IoC containers do not mind tight coupling between application components. For instance, IoC containers can be used to wire up one component to another it depends by a reference of concrete implementation type rather than by interface or abstract class type. 

Secondly, although appearing as a common character and playing a critical role in all IoC containers, neither inversion of control in general nor dependency injection in particular is what IoC containers primarily focus to *_do_* but what they simply *_use_*. This is just like an electric car is not to *_make_* electricity, it simply *_use_* it for its real purpose similar to non-electric cars.

For years, this misunderstanding on IoC containers has been widely bought. Consequently, many frameworks that tagged as “IoC containers” nowadays are merely programming libraries focusing on _doing DI without leaving the same programming language_. Although these DI programming frameworks are useful in many cases, their objectives are orthogonal to and at a level different from IoC containers. This is similar to the difference between traditional component frameworks (such as the old pre-2.x EJB and OMG CCM) that use table/directory lookup design and those programming frameworks or libraries that provide table/directory implementations (such as java.util, javax.naming, and C++ STL/boost libraries). To avoid further confusing, people have suggested differentiate true IoC containers from these DI programming frameworks or libraries.

== IoC containers are about modeling application ontology and manipulate them as first class objects ==
The primary focus of IoC containers is to fabricate applications, from service and business logic components, based on separated assembly and deployment description modules. However, distinct from their counterpart in DI frameworks that emphasize on doing DI without leaving the imperative languages, these description modules in IoC containers have the following two features:

- Firstly, they are *_[http://en.wikipedia.org/wiki/Declarative_programming declarative]_* and describe the _[http://en.wikipedia.org/wiki/Ontology_%28information_science%29 ontological]_ aspects (namely *_what_* are the configurations and dependency relations of involved components) of their applications rather than the _[http://en.wikipedia.org/wiki/Imperative_programming imperative]_ procedures (namely *_how_*) to set up these ontology.

- Secondly, they are *_[http://en.wikipedia.org/wiki/First-class_object first class objects]_* of some declarative languages. This means that these description modules can be manipulated (such as to be generated, transformed, refactored, aggregated, filtered, queried, and verified) explicitly by high level declarative code.

These two seemingly plain features not only have non-trivial and paradigm shifting implications far beyond the DI design pattern or the IoC principle itself, but also differentiate IoC containers from imperative scripting language environments.

The declarative feature of these description modules makes the ontology of their applications intuitive, self-documenting, and helps one to see the forest beyond the trees of the described applications. It also allows domain, context, and referential constraints to be imposed on these description modules and implies more rich and strong schema check than the primitive type check of classic imperative languages (Java and C++). 

The second feature, suggested by this article to be highlighted for IoC containers, turns out to be more distinct and is the one that implies the paradigm shift (especially in imperative language, such as Java and C++, environments). However, this feature has largely been neglected or unaware even by many IoC folks. Although many IoC containers happen to support this feature, few of them have intentionally attempted to leverage it, largely due to the religious of everything should be and better to be done within the original imperative programming language.

As discussed in the article of [http://www.pocomatic.com/docs/whitepapers/dsm/ Domain Specific Modeling in IoC frameworks], component frameworks, either IoC or not, all face the dilemma of expressiveness and diversity vs. intuitiveness and simplicity of the schema(s) of their declarative description modules. Knowing that there is no one-size-fits-all solution, the best approach to address this dilemma is to allow users to define customized, highly expressive, and error-proof domain specific modeling (DSM) schema(s) for their specific application ontology descriptions. However, supporting these DSM schemas by a component framework implies low level and error-prone programming effort that tend to be very cost-ineffective. The second feature of IoC description modules presents a cost-effective solution here. Because these modules are manipulatable by declarative code, it allows error-proof DSM transformation templates to be much easily authored at high level. Then, with these templates, description modules in DSMs can be transformed into modules in built-in core schemas of IoC containers, as illustrated by [http://code.google.com/p/pococapsule PocoCapsule IoC and DSM framework] and its [http://www.pocomatic.com/docs/cpp-examples/ examples].